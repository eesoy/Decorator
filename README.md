# Decorator

#### <i class="icon-pencil"></i>  정의  

데코레이터 패턴에서는 객체에 추가적인 요건을 동적으로 첨가한다. 데코레이터는 서브클래스를 만드는 것을 통해서 기능을 유연하게 확장할 수 있는 방법을 제공한다.


## 패턴 활용처 
+ 다른 객체에 영향을 주기 않고, 특정 객체에게 동적으로 새로운 기능을 추가 또는 삭제하고자 할 때 특히 client 측에서 이렇게 새로운 기능이 추가된 객체와 그렇지 않은 객체를 따로 구분하고 싶지 않을 때
+ 클래스 상속을 통한 기능 확장이 불가능하거나 어려울 때

## 장점 
+ Decorator 패턴은 객체에 기능을 추가하고자 할 때 동적으로 중간중간 원하는 객체에게 기능을 추가하거나 삭제할 수 있다
+ 동일한 기능을 반복하는 것이 간편해진다. 반복 수행하고 싶은 횟수만큼 객체를 생성한 후 이들을 하나의 연결고리로 연결하면 되기 때문이다.
+ 처음부터 복잡하게 구조를 정의하는 것이 아니고, 간단한 클래스만을 정의해 두었다가 필요할 경우 새로운 클래스들을 조금씩 확장시켜나가는 방식이다.

## 단점
+ Decorator 패턴을 적용시킬 경우 클래스 수는 줄지만 객체의 수는 많아질 수 있다. 또한 객체가 비슷비슷 하게 보여서 Decorator 패턴에 대해 잘 이해하지 못할 경우 디버깅하기가 쉽지 않다.


## 디자인 원칙
+ 클래스는 확장에 대해서는 열려 있어야 하지만 코드 변경에 대해서는 닫혀 있어야 한다.(OCP: Open-Closed Principle)


## 동작과정
+ 트리에 사용할 나무를 가져온다.
+ 나무에 장식할 옵션을 추가한다.
+ cost()메소드를 호출한다. 이때 첨가물의 가격을 계산하는 일은 해당 첨가물 객체에게 위임한다.

## 구성요소
+ 최상위 구성요소 - Tree
+ Tree를 상속하는 추상 데코레이터, Tree를 확장 - DecoOption 
+ 실제 구성 요소(나무 종류), Tree를 확장  - Juniper, Oak, Pine 
+ 데코레이터, DecoOption을 확장 - Cherrybulb, SantaOrnament, StarOrnament
